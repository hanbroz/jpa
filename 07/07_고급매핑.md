# 07. 고급매핑

## 7.1 상속 관계 매핑

관계형 DB는 상속이라는 개념이 없음 > 슈퍼타입과 서브타입이 존재 함

![image](https://github.com/hanbroz/jpa/blob/master/07/images/img7_1.png)<br>
<슈퍼타입과 서브타입 논리모델>

![image](https://github.com/hanbroz/jpa/blob/master/07/images/img7_2.png)<br>
<객체 상속 모델>

테이블로 구성하는 3가지 전략

1. 각각의 테이블로 정의 (중복데이터 발생)
2. 통합 테이블로 변환 (역정규화)
3. 서브타입 테이블로 변환 (정규화)

### 7.1.1 조인 전략

Entity를 각각의 테이블로 만들고 자식 테이블이 부모의 PK를 받아서 PK+FK로 사용하는 전략 > Join이 자주 사용됨 > 테이블에 타입을 구분할 수 있는 컬럼이 필요함

![image](https://github.com/hanbroz/jpa/blob/master/07/images/img7_3.png)<br>
<식별관계구성>

~~~java

@Entity
@Inheritance(strategy = Inheritance.JOINED) //상속매핑은 부모 클래스에 @Inheritance를 사용해야 한다. JOIN 전략 사용
@DiscriminatorColumn(name = "DTYPE") // 부모 클래스에서 사용할 구분컬럼을 지정
public abstract class Item {
    ...
}

@Entity
@DiscriminatorValue(ItemType.ALBUM)
public class Album extends Item {
    ...
}

@Entity
@DiscriminatorValue(ItemType.MOVIE) // Entity를 저장할 때 구분 컬럼에 입력할 값을 지정, M을 지정하면 DTYPE에는 "M"이 들어간다. ENUM화 필요
public class Movie extends Item {
    ...
}

public enum ItemType {
    
    ALBUM("A000")
    , MOVIE("A010")
    , BOOK("A020")
    
}

~~~

기본적으로 자식 테이블은 부모 테이블의 ID 컬럼명을 그대로 사용하게 되는데 변경하려고 하는 경우 다음과 같이 선언 함

![image](https://github.com/hanbroz/jpa/blob/master/07/images/img7_3_1.png)<br>
<서브타입 키 변경>

~~~java

@Entity
@DiscriminatorValue(ItemType.BOOK) // Entity를 저장할 때 구분 컬럼에 입력할 값을 지정, M을 지정하면 DTYPE에는 "M"이 들어간다. ENUM화 필요
@PrimaryKeyJoinColumn(name="BOOK_ID")
public class BOOK extends Item {
    ...
}

~~~

**장점**

* 테이블이 정규화 된다.
* FK 참조 무결성 제약조건을 활용할 수 있다.
* 저장공간을 효율적으로 사용할 수 있다.

**단점**

* JOIN이 많이 사용되어 성능이 저하될 수 있다. (모든 ITEM을 자주 가져와야 하는 상황)
* 조회 쿼리가 복잡하다.

~~~sql

SELECT * FROM ITEM
LEFT JOIN ALBUM
ON ITEM.ITEM_ID = ALBUM.ITEM_ID
LEFT JOIN MOVIE
ON ITEM.ITEM_ID = MOVIE.ITEM_ID
LEFT JOIN BOOK
ON ITEM.ITEM_ID = BOOK.BOOK_ID 

~~~

* 테이터 등록에 두번의 INSERT 가 발생한다.

~~~sql

INSERT MOVIE ..
INSERT ITEM ..

~~~

**특징**

JPA 표준 명세서에서는 구분 컬럼을 사용하도록 하지만 하이버네이트를 포함한 몇몇 구현체는 구분 컬럼이 없어도 동작함

 ### 7.1.2 단일 테이블 전략
 
 한개의 테이블에 합친 형태로 (역정규화) 구분자(DTYPE)을 두며 단일 테이블로 가장 속도가 빠르다.
 
 ![image](https://github.com/hanbroz/jpa/blob/master/07/images/img7_4.png)<br>
 <단일 테이블 : 데이터에 비효율이 발생, 쿼리가 단순화 된다.>
 
 ~~~java
 
 @Entity
 @Inheritance(strategy = Inheritance.SINGLE_TABLE)
 @DiscriminatorColumn(name = "DTYPE") // 부모 클래스에서 사용할 구분컬럼을 지정, 필수
 public abstract class Item {
     ...
 }
 
 @Entity
 @DiscriminatorValue(ItemType.ALBUM)
 public class Album extends Item {
     ...
 }
 
 @Entity
 @DiscriminatorValue(ItemType.MOVIE) // Entity를 저장할 때 구분 컬럼에 입력할 값을 지정, M을 지정하면 DTYPE에는 "M"이 들어간다. ENUM화 필요
 public class Movie extends Item {
     ...
 }
 
 public enum ItemType {
     
     ALBUM("A000")
     , MOVIE("A010")
     , BOOK("A020")
     
 }
 
 ~~~
 
 **장점**
 
 * 조회 성능이 빠르다.
 * 쿼리가 단순하다.
 
 **단점**
 
 * null을 허용하는 컬럼이 필수적으로 발생한다.
 * 정규화를 따르지 않는다. (역정규화 되어 있음)
 * ROW가 상대적으로 많기 때문에 이 상태에서 다른 테이블과 JOIN이 걸리면 오히려 성능이 더 떨어질 수 있다.
 
 **특징**
 
 * 구분컬럼이 반드시 필요하다.
 * @DiscriminatorValue 를 지정하지 않으면 Entity이름을 그대로 사용한다. (Album, Movie, Book)
 
 ### 7.1.3 각각의 테이블로 만드는 경우
 
 ![image](https://github.com/hanbroz/jpa/blob/master/07/images/img7_5.png)<br>
  <CONCRETE TABLE>
  
  ~~~java
   
   @Entity
   @Inheritance(strategy = Inheritance.TABLE_PER_CLASS)
   public abstract class Item {
       ...
   }
   
   @Entity
   public class Album extends Item {
       ...
   }
   
   @Entity
   public class Movie extends Item {
       ...
   }
   
   public enum ItemType {
       
       ALBUM("A000")
       , MOVIE("A010")
       , BOOK("A020")
       
   }
   
~~~

추천하지 않는 전략.. (많이 생소한 DB 모델링)

**장점**

* 서브타입을 구분하여 구현할 떄 효과적
* not null 제약조건 사용가능

**단점**

* 전체 ITEM을 조회할때 가장많은 OVERHEAD 발생 (UNION 사용)

**특징**

* 구분컬럼을 사용하지 않는다.
* DB와 ORM 모두에서 추천하지 않는 방법

## 7.2 @MappedSuperclass

이전에는 부모/자식 클래스를 모두 DB 테이블과 매핑 했으나 상속 받은 자식 클래스에게 매핑 정보만 제공하고 싶은 경우

**@MappedSuperclass (추상클래스 개념와 유사)**

를 사용하면 된다. (NICE ~ 내가 찾던거..)


![image](https://github.com/hanbroz/jpa/blob/master/07/images/img7_7.png)<br>
<테이블의 공통 요소>

~~~java

@MappedSuperclass // 해당 어노테이션으로 정의된 클래스는 직접 사용하지 않는 경우가 많으므로 추상화 하는데 좋다.
public abstract class BaseEntity {
    private Long id;
    private String name;
}

@Entity
public class Member extends BaseEntity {
    private String email;
}

@Entity
public class Seller extends BaseEntity {
    private String shopName;
}

~~~

다음과 같이 재정의도 가능하다.

~~~java

@Entity
@AttributeOverride(name = "id", column = @Column(name = "MEMBER_ID")) // 한개 속성 재정의
public class Member extends BaseEntity {
    ...
}

@Entity
@AttributeOverrides ({ // 여러개를 재정의
@AttributeOverride(name = "id", column = @Column(name = "MEMBER_ID")),
@AttributeOverride(name = "name", column = @Column(name = "MEMBER_NAME")),
})

public class Member extends BaseEntity {
    ...
}

~~~

### 7.3 복합 키와 식별 관계 매핑



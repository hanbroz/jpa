# 13. 웹 애플리케이션과 영속성 관리

컨테이너 환경에서 JPA 동작하는 방식을 이해하고 발생할 수 있는 다양한 문제점과 해결 방안 탐구

## 13.1 트랜잭션 범위의 영속성 컨텍스트

순수한 J2SE 환경에서는 개발자가 Entity Manager를 생성하고 트랜잭션도 관리해야 하지만 Spring, J2EE 컨테이너 환경에서 JPA를 사용하면 컨테이너가 제공하는 전략을 따라야 함

### 13.1.1 스프링 컨테이너의 기본 전략

스프링 컨테이너는 트랜잭션 범위의 연속성 컨텍스트 전략을 기본으로 사용

![image](https://github.com/hanbroz/jpa/blob/master/13/images/img13_1.png)

트랜잭션 시작 > 영속성 컨텍스트 생성
트랜잭션 종료 > 영속성 컨텍스트 종료
동일 트랜잭션 = 동일 영속성 컨텍스트

스프링에서 비즈니스 로직을 시작하는 서비스 계층에 @Transactional을 붙여 트랜잭션을 시작 > 메서드 호출 하기전 스프링 트랜잭션 AOP가 먼저 동작하는 방식 임

> 중요 : 트랜잭션 커밋 > 영속성 컨텍스트 Flush > DB반영 > Commit;

![image](https://github.com/hanbroz/jpa/blob/master/13/images/img13_2.png)


~~~java

public void ch13_hello() {
    // 반환된 member Entity는 준영속 상태다.
    // Service 에서 이미 트랜잭션을 종료 했기 때문에 준영속 상태
    MemberEntity member = ch13MemberService.ch13logic();
}

@Transactional
public MemberEntity ch13logic() {

    memberRepository1.hello();

    MemberEntity member = memberRepository2.findMember(this.id);
    return member;
}

@PersistenceContext
EntityManager em;

public MemberEntity findMember(Long id) {
    return em.find(MemberEntity.class, id);
}

public List<MemberEntity> findAll() {
    return em.createQuery("select m from MemberEntity m", MemberEntity.class)
            .getResultList();
}

~~~

![image](https://github.com/hanbroz/jpa/blob/master/13/images/img13_3.png)<br>
트랜잭션이 같으면 같은 영속성 컨텍스트를 사용한다.





# 10. 객체지향 쿼리 언어

## 10.1 객체지향 쿼리 소개

기존 방식만으로 개발을 완료하기 어려움 > 현실적으로 복잡합 쿼리가 필요하다.

JPA 공식 제공

* JPQL (가장중요)
* Criteria SQL
* Native SQL

JPA 공식 외

* QueryDSL : Criteria SQL과 유사
* JDBC 직접사용

### 10.1.1 JPQL 소개

SQL 추상화해서 특정 DB에 의존하지 않는다. RUN TIME이 되어야 오류를 확인할 수 있다.

~~~java

String jpql = "select m from Member as m where m.UserName = '이성재'";
List<Member> items = em.createQuery(jpql, Member.class).getResultList();

~~~

~~~sql

/* select
        m 
    from
        Member as m 
    where
        m.UserName = '이성재' */ select
            member0_.id as id1_0_,
            member0_.name as name2_0_ 
        from
            Member member0_ 
        where
            member0_.name='이성재'
            
~~~

### 10.1.2 Criteria

쿼리를 프로그래밍 하여 작성, 문자열로 작성에 따른 오류를 사전에 알 수 있음

"userName" > 문자열이기 때문에 런타임때 오류로 확인하는 것은 마찬가지 > 어노테이션 프로세서 기능을 사용하면 가능 (메타모델)

쿼리를 코드로 작성할 수 있으나 너무 장황하고 복잡하다..

~~~java

// 사용준비
CriteriaBuilder cb = em.getCriteriaBuilder();
CriteriaQuery<Member> query = cb.createQuery(Member.class);

// 루트 글래스(조회를 시작할 클래스)
Root<Member> m = query.from(Member.class);

// 쿼리생성
CriteriaQuery<Member> cq = query.select(m)
        .where(cb.equal(m.get("UserName"), "이성재"));

List<Member> items = em.createQuery(cq).getResultList();

~~~

~~~sql

/* select
        generatedAlias0 
    from
        Member as generatedAlias0 
    where
        generatedAlias0.UserName=:param0 */ select
            member0_.id as id1_0_,
            member0_.name as name2_0_ 
        from
            Member member0_ 
        where
            member0_.name=?
            
~~~

### 10.1.3 QueryDSL 소개

코드기반, 단순하고 사용하기 쉬움, 표준 프로젝트가 아니라 오픈소스 프로젝트 임

~~~java

// 준비
JPAQuery query = new JPAQuery(em);
QMember member = QMember.member;

// 쿼리, 결과조회
List<Member> items = query.from(membe)
                        .where(member.UserName.eq("이성재"))
                        .list(member);

~~~

### 10.1.4 네이티브 SQL 소개

SQL을 직접 사용할 수 있도록 하는 것으로 특정 DB에 의존적인 동작을 지정해야 할 경우가 있다. (ORACLE CONNECT BY)

### 10.1.5 JDBC를 직접 사용, 마이바티스 같은 SQL 매퍼 프레임워크 사용

현실적으로 드문일, JPA는 JDBC 커넥션을 획득하는 API를 제공하지 않기 때문에 JPA 구현체가 제공하는 방법을 사용해야 함

영속성 컨텍스트를 DB와 불일치 시켜 무결성을 훼손 할 수 있다.

이 경우 영속성 컨텍스트를 강제로 Flush해야 한다. > AOP를 통해 동기화 하면 깔끔하게 문제를 해결 할 수 있다.

~~~java

Session session = em.unwrap(Session.class);
session.doWork(new Work() {
    
    @Override
    public  void execute(Connection conn) throws SQLException {
        // work..
    }
});

~~~

## 10.2 JPQL

### 10.2.1 기본 문법과 쿼리 API

CRUD는 RUD는 있으나 C는 영속성 컨텍스트에서 진행하기 때문에 없다.

* 대소문자 구분 : 키워드는 구분하지 않으며 Entity와 속성은 대문자를 구분한다.
* 엔티티 이름 : 클래스명이 아니라 Entity의 명이다. 클래스명을 Entity명으로 사용하는 것이 좋다.
* 별칭은 필수 : 별칭을 사용하지 않으면 오류가 발생한다.

TypeQuery vs Query

TypeQuery : 반환할 타입이 명확한 경우
Query : 반환형이 명확하지 않음

~~~java

TypedQuery<Member> query = em.createQuery("SELECT m FROM Member m", Member.class);
List<Member> items = query.getResultList();



Query query = em.createQuery("SELECT m.UserName, m.id FROM Member m");
//Query query = em.createQuery("SELECT m FROM Member m"); // Error

List items = query.getResultList();

System.out.println("Query -----------------------");
System.out.println("ID / NAME ------------------------");
for(Object member : items) {

    Object[] result = (Object[])member; // m.*로 조회하면 오류가 남, 컬럼이 한개면 Object, 여러개면 Object[]

    System.out.println(result[0]+" / "+result[1]+" -------------------------");
}
System.out.println("----------------------------------");

~~~

결과조회

query.getResultList();
query.getSingleResult(); > 반환향이 없거나 여러개면 오류가 발생함

### 10.2.2 파라미터 바인딩

* 이름 기준 파라미터, 여러개의 파라미터를 체인으로 연결 할 수 있다.

~~~java

String userNameParam = "이성재";

TypedQuery<Member> query = em.createQuery("SELECT m FROM Member m WHERE m.UserName = :userName", Member.class);

query.setParameter("userName", userNameParam);

List<Member> items = query.getResultList();

System.out.println("TypedQuery -----------------------");
System.out.println("ID / NAME ------------------------");
for(Member member : items) {
    System.out.println(member.getId()+" / "+member.getUserName()+" -------------------------");
}
System.out.println("----------------------------------");
            
~~~

* 위치 기준 파라미터, 좋지 않은 방법, 이름 기준으로 하는것이 명확

~~~java

List<Member> items = em.createQuery("SELECT m FROM Member m WHERE m.UserName = ?1", Member.class)
        .setParameter(1, "이성재")
        .getResultList();

System.out.println("TypedQuery -----------------------");
System.out.println("ID / NAME ------------------------");
for(Member member : items) {
    System.out.println(member.getId()+" / "+member.getUserName()+" -------------------------");
}
System.out.println("----------------------------------");

~~~

SQL INJECTION을 대비하기 위해서는 파라미터 바인딩을 반드시 사용해야 한다.

### 10.2.3 프로젝션

임베디드 타입은 엔티티 타입이 아닌 값 타입이어서 직접조회한 임베디드 타입은 영속성 컨텍스트에서 관리되지 않는다.

* 여러 값 조회

~~~java

Query query = em.createQuery("SELECT m.userName, m.age FROM Member m");

List resultList = query.getResultList();

Iterator iterator = resultList.iterator();

while(iterator.hasNext()) {
    Object[] row = (Object[])iterator.next();
    String userName = (String)row[0];
    Integer age = (Integer)row[1];

    System.out.println(userName+" / "+age+" -------------------------");
}

~~~

* NEW 명령어

1) 패키지명을 포함한 전체 경로
2) DTO에 생성자 필요

~~~java

List<UserDTO> resultList = em.createQuery("SELECT new jpabook.dto.UserDTO(m.userName, m.age) FROM Member m", UserDTO.class).getResultList();

System.out.println("TypedQuery -----------------------");
System.out.println("ID / NAME ------------------------");

for(UserDTO dto : resultList) {

    System.out.println(dto.getUserName()+" / "+dto.getAge()+" -------------------------");
}

System.out.println("----------------------------------");

~~~

### 10.2.4 페이징 API

각 DB에 따른 방언별로 쿼리가 생성된다.

~~~java

TypedQuery<UserDTO> query = em.createQuery("SELECT new jpabook.dto.UserDTO(m.userName, m.age) FROM Member m", UserDTO.class);

query.setFirstResult(2);
query.setMaxResults(20);

List<UserDTO> resultList = query.getResultList();
            
~~~

~~~sql

/* SELECT
        new jpabook.dto.UserDTO(m.userName,
        m.age) 
    FROM
        Member m */ select
            member0_.name as col_0_0_,
            member0_.age as col_1_0_ 
        from
            Member member0_ limit ? offset ?
            
~~~


### 10.2.5 집합과 정렬

### 10.2.6 JPQL 조인

* 내부 조인
* 외부 조인
* 세타 조인 (내부 조인만 가능)
* JOIN ON (외부 조인만 가능)

### 10.2.7 페치 조인

* Entity 페치 조인 : 회원을 조회하면서 한꺼번에 Team을 가지고 옴, fectch 이후 m.team에 별칭이 없는게 특징

~~~java

String query = "SELECT m FROM Member m JOIN FETCH m.team";
List<Member> members = em.createQuery(query, Member.class).getResultList();
            
~~~

 ~~~sql
 
 select m from Member m join fetch m.team
 
 ~~~
 
 페치 조인이 되면 지연로딩 설정이 되어도 지연로딩이 아니다.
 
 * 컬렉션 페치 조인
 
 연관된 회원 정보도 같이 조회한다.
 
 ~~~sql
 
 /* SELECT
         t 
     FROM
         Team t 
     JOIN
         FETCH t.members 
     WHERE
         t.name = '팀A' */ select
             team0_.TEAM_ID as TEAM_ID1_1_0_,
             members1_.MEMBER_ID as MEMBER_I1_0_1_,
             team0_.name as name2_1_0_,
             members1_.age as age2_0_1_,
             members1_.TEAM_ID as TEAM_ID4_0_1_,
             members1_.name as name3_0_1_,
             members1_.TEAM_ID as TEAM_ID4_1_0__,
             members1_.MEMBER_ID as MEMBER_I1_0_0__ 
         from
             Team team0_ 
         inner join
             Member members1_ 
                 on team0_.TEAM_ID=members1_.TEAM_ID 
         where
             team0_.name='팀A'
 ~~~
 
 Team과 Member를 JOIN하기 때문에 Team이 두개의 행을 반환한다.
 
 * 페치 조인과 DISTINCT
 
 ~~~java
 
String query = "SELECT distinct t FROM Team t JOIN FETCH t.members WHERE t.name = '팀A'";
 
List<Team> teams = em.createQuery(query, Team.class).getResultList();
             
 ~~~
 
 * 페치 조인과 일반 조인의 차이
 
 ~~~java
 
 String query = "SELECT t FROM Team t JOIN t.members WHERE t.name = '팀A'";
 
 ~~~
 
 ~~~sql
 
 /* SELECT
         t 
     FROM
         Team t 
     JOIN
         t.members 
     WHERE
         t.name = '팀A' */ select
             team0_.TEAM_ID as TEAM_ID1_1_,
             team0_.name as name2_1_ 
         from
             Team team0_ 
         inner join
             Member members1_ 
                 on team0_.TEAM_ID=members1_.TEAM_ID 
         where
             team0_.name='팀A'
             
 ~~~
 
 페치 조인과 다르게 일반 조인은 팀만 조회하고 회원을 전혀 조회하지 않는다. >> 회원에 대해서는 프록시나 초기화하지 않은 래퍼를 반환한다.
 
 * 페치 조인의 특징과 한계
 
 페치 조인 대상에는 별칭을 줄 수 없다.
 둘 이상의 컬렉션을 패치할 수 없다.
 컬렉션을 페치 조인하면 페이징 API를 사용할 수 없다.
 
 페치조인이 항상 효과적인 것은 아니다. 전혀 다는 결과를 패치해야 한다면 해당하는 DTO를 만들어서 반환하는 것이 더 효과적일 수 있다.
 
 ### 10.2.8 경로 표현식
 
 경로표현식 : .을 찍어 객체 그래프를 탐색하는 방법, 아래에서 m.name
 
 ~~~sql
 
 select m.name from Member m
 
 ~~~
 
**경로 표현식 용어정리**
 
* 상태필드 : 단순히 값을 저장하기 위한 필드 > 경로 탐색의 끝

~~~sql

select m.name, m.age from Member m

~~~


* 연관필드 : 
단일값 > 묵시적으로 내부 조인이 발생한다. > 계속 탐색할 수 있다.

~~~sql

select o.member from Order o

~~~

컬렉션 연관 필드 : 묵시적으로 내부 조인이 발생한다. > 더는 탐색할 수 없다.

**컬렉션 값 연관 경로 탐색**

~~~sql

select t.members from Team t -- 성공
select t.members.username from Team t -- 실패

select m.username from Team t join t.members m -- 이렇게 변경

select t.members.size from Team t -- count 함수와 같은 효과

~~~

**경로 탐색을 사용한 묵시적 조인 시 주의사항**

* 항상 내부 JOIN
* 컬렉션은 경로 탐색의 끝이다. 컬렉션에서 경로 탐색을 하려면 명시적으로 조인의 별칭을 얻어야 한다.
* 경로 탐색은 주로 SELECT, WHERE에서 사용하지만 묵시적 조인으로 인해 SQL의 FROM절에 영향을 준다.

JOIN은 성능에 큰 영향을 미친다. 명시적으로 JOIN을 사용하도록 해야 한다.

### 10.2.9 서브 쿼리

서브 쿼리를 지원하지만 WHERE, HAVING (O), SELECT, FROM (X)

~~~sql

select m from Member m where m.age > (select avg(m2.avg) from Member m2) -- 평균나이보다 많은 사람
select m from Member m where (select count(o) from Order o where m = o.member) > 0 -- 한건 이상 주문고객
select m from Member m where m.orders.size > 0 -- 한건 이상 주문고객

~~~

서브 쿼리 함수

EXIST, ALL, ANY, SOME, IN

### 10.2.10 조건식

~~~sql

select m from Member m where m.age between 10 and 20;
select m from Member m where m.username in ('회원명1','회원명2');
select m from Member m where m.username like '%원%';
select m from Member m where m.username is null;
select m from Member m where m.orders is not empty;
select m from Member m where m.orders is null (X)

~~~

**날짜함수**

날짜 타입에 대해서 기본 함수 제공, to_date, to_char 오라클 함수를 지원하지만 호환되지는 않는다.
: 그럼 문자열 날짜는 어떻게 해야 할까?

~~~java

String date = "2013.11.05";
Date checkDate = new SimpleDateFormat("yyyy.MM.dd").parse(date);

String  qString = 
"SELECT DISTINCT T " +
"FROM T5PFArfolyamArch T " +
"WHERE T.arfTipus = :vcRateKod AND T.arfErvkezd = :checkDate AND T.araValid IN ('I','M')";

Query query = entityManager.createQuery(qString);
query.setParameter("vcRateKod", tipus);
query.setParameter("checkDate", checkDate, TemporalType.DATE);

~~~

~~~java

List<Member> members = em.createQuery("SELECT m FROM Member m where m.regDTS > CURRENT_DATE", Member.class).getResultList(); // 문자열 vs 날짜??

~~~

**CASE**

~~~sql

select 
    case when m.age <=10 then '학생요금'
         when m.age >=60 then '경로요금'
         else '일반요금'
    end 
from Member m 
  
select
    case t.name
         when '팀A' then '인센티브110%'
         when '팀B' then '인센티브120%'
         else '인센티브100%'
     end
  from Member m

select coalesce(m.username, '이름 없는 회원')
  from Member m -- m.username이 null이면 '이름 없는 회원 반환'
  
  Result -----------------------
  이성재-------------------------
  한석규-------------------------
  이름 없는 회원-------------------------
  ----------------------------------

select nullif(m.username, '관리자') from Member m; -- 이름이 관리자라면 NULL을 반환

~~~

### 10.2.11 다형성 쿼리

**TYPE**

~~~sql

select i from Item i
where type(i) IN (Book, Movie);

select i from Item i
where i.DTYPE in ('B','M')

~~~

**TREAT(JPA 2.1)**

자바의 타입 캐스팅과 유사

~~~sql

select i from Item i where treat(i as Book).author = 'kim'

select i.* from i where i.DTYPE ='B' and i.author = 'kim';

~~~

### 10.2.12 사용자 정의 함수 호출(JPA 2.1)

~~~sql

select function('group_concat', i.name) from Item i

~~~

~~~java

public class MyH2Dialect extends H2Dialect {
    
    public MyH2Dialect() {
        registerFunction("group_concat", new StandardSQLFunction("group_concat", StandardBasicType.STRING));
    }
}

~~~

~~~xml

<property name="hibernate.dialect" value="hello.MyH2Dialect" />

~~~

### 10.2.13 기타 정리

* enum은 비교 연산만 지원한다.
* 임베디드 타입은 비교를 지원하지 않는다.

JPA 표준은 ''을 길이 0인 EMPTY String으로 정했지만 DB에 따라 ''를 NULL로 사용하는 DB가 있다. (ORACLE)

### 10.2.14 엔티티 직접 사용

**기본 키(PK) 값**

id가 PK라면 아래 쿼리는 같다.

~~~sql

select count(m.id) from Membmer m;
select count(m) from Member m;
select m from Member m where m = :member;

~~~

**외래 키(FK) 값**

~~~sql

select m from Member m where m.team = :team;

~~~


### 10.2.15 Named 쿼리 : 정적 쿼리

**동적쿼리**

JPQL을 문자열로 조합하여 넘기는 것

**정적쿼리**

미리 정의한 쿼리에 이름을 부여해서 필요할 때 사용, **Named 쿼리**라고 한다.

Named 쿼리는 APP 로딩시 문법을 미리 체크하고 파싱해 둔다. >> 빠른 오류 확인, 재사용 가능, 캐시되어 성능 최적화

**Named 쿼리를 어노테이션에 정의**

~~~java

@Entity
@NamedQuery(
    name = "Member.findByUserName",
    query = "select m from Member m where m.username = :username")
public class Member {
    
}

@Entity
@NamedQuerys({
@NamedQuery(name = "Member.findByUserName1",
                query = "select m from Member m where m.username = :username"),
@NamedQuery(name = "Member.findByUserName2",
                query = "select m from Member m where m.username = :username")
})
public class Member {
    
}

List<Member> members = em.createNamedQuery("Member.findByUserName", Member.class).setParameter("userName","한석규").getResultList();

~~~

**Named 쿼리를 XML에 정의**

쿼리를 어노테이션으로 지정하는 일은 번거럽고 다루기 어렵다. (멀티라인 등 처리)
XML로 관리하는 것이 훨씬 직관적으로 수 있다.

1) xml에 쿼리지정

~~~xml

<?xml version="1.0" encoding="UTF-8"?>
<entity-mappings xmlns="http://java.sun.com/xml/ns/persistence/orm" version="2.1">

    <named-query name="Member.findByUserName">
        <query>select m from Member m where m.userName = :userName</query>
    </named-query>

    <named-native-query name="Member.findAll" result-class="dto.MemberList">
        <query>select m.userName, m.age from Member m where m.age = :age</query>
    </named-native-query>

</entity-mappings>

~~~

2) persistence.xml에 코드 추가

~~~xml

<persistence-unit name="jpabook">
    <mapping-file>META-INF/ormMember.xml</mapping-file>
</persistence-unit>

~~~

어노테이션과 XML에서 XML이 우선권을 가진다.











 
 
 
 
 
 











